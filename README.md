# Задача: реализовать жадный ln(n)-аппроксимационный алгоритм для задачи о покрытии множеств.
# Результаты: 
Выбранные множества:
* S1 = {1, 10, 4, 7}
* S2 = {8, 9, 5, 6}
* S3 = {1, 2, 3}
* Общее количество элементов: 11
# Описание алгоритма 
* -def greedy_set_cover(universe, subsets):  -объявление функции, принимает универсум и список подмножеств.
* -covered = set() -создаем множество covered, которое отслеживает покрытые элементы.
* -selected = [] -список для выбранных множеств.
* -while covered != universe: -пока все элементы не покрыты.
* -best_subset = max(subsets, key=lambda s: len(s - covered))  -на каждом шаге выбираем множество из subsets, которое покрывает максимум ещё не покрытых элементов. s - covered — множество элементов множества s, которых ещё нет в покрытии.
* -selected.append(best_subset) -добавляем выбранное множество в список ответов.
* -covered |= best_subset  -добавляем новые закрытые элементы к существующим.
# Временная сложность
( O(n \times m) )
# Почему такая:
Каждая итерация цикла while выбирает максимум из ( m ) множеств по критерию — это делается за ( O(m \times s) ), где ( s ) — средний размер множества (обычно очень маленькое, поскольку len(s - covered) — размер разницы, что быстро считается). Общее количество итераций — максимум ( n ), потому что за каждую итерацию покрывается хотя бы один элемент. Обобщая, получается приблизительно ( O(n \times m \times s) ).
# Контрольный вопрос: 
* Вопрос: Почему жадный алгоритм для 0-1 рюкзака не гарантирует оптимальное решение? Приведите
контрпример.
* Ответ: 
